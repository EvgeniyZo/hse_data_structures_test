4. Сравнить несколько алгоритмов сортировки

|   Название сортировки  |     Асимптотика          |         Плюсы            |               Минусы                  |
| :--------------------: | :----------------------: | :----------------------: | :------------------------------------:|
|  Сортировка пузырьком  |  O(n^2)                  |  Прост в реализации      |  Медленно при больших объемах данных  |
|  Быстрая сортировка    |  O(n log n)              |  Эффективен на практике  |  Может быть нестабилен                |
|  Сортировка слиянием   |  O(n log n)              |  Стабильная              |  Занимает дополнительную память       |
|  Сортировка вставками  |  O(n^2) в худшем случае  |  Прост в реализации      |  Медленно при больших объемах данных  |
|  Сортировка выбором    |  O(n^2)                  |  Прост в реализации      |  Медленно при больших объемах данных  |

5. Реализовать алгоритм бинарного поиска. Рассказать об особенностях его применения. 
Файл: bin_search.py
Примечание:
	1. Входной список должен быть отсортирован.
	2. Если числа нет в списке, возвращает 0.

6. Перечислить способы представления графа в памяти компьютера и случаи их применения

  a. Матрица смежности: граф представляется в виде таблицы, где строки и столбцы соответствуют вершинам, а элементы указывают на наличие или отсутствие ребра между вершинами.
Применяется в случаях, когда необходимо быстро определять наличие ребер между конкретными вершинами.

  b. Список смежности: каждая вершина графа хранит список вершин, с которыми она соединена. 
Эффективен для работы с разреженными графами и когда требуется хранить дополнительную информацию о вершинах.

  c. Список ребер: представление графа в виде списка всех ребер. 
Это удобно для быстрой итерации по всем ребрам графа.

  d. Древовидное представление графа: граф рассматривается как древовидная структура, где у каждой вершины может быть указатель на ее потомков. 
Применяется в случаях, когда граф представляет собой дерево.

  e. Список инцидентности: представление графа в виде списка, где каждое ребро связывает две вершины. 
Применяется в случаях, когда необходимо быстро находить все инцидентные вершины для данного ребра.

7. Рассказать о сложности алгоритмов 

Сложность алгоритма (или асимптотическая сложность) — это понятие, описывающее поведение времени работы или используемой памяти алгоритма при увеличении размера входных данных.
Асимптотика алгоритма позволяет оценить его эффективность на больших данных и сравнивать разные алгоритмы независимо от конкретной реализации.

Существуют несколько видов асимптотической сложности:

1. Временная сложность:
   - O-большое (Big O): описывает верхнюю границу роста времени выполнения алгоритма. Например, \(O(n)\) означает линейную сложность, \(O(n^2)\) — квадратичную и т.д.
   - Ω-большое (Big Omega): описывает нижнюю границу роста времени выполнения алгоритма.
   - Θ-обозначение (Big Theta): описывает точную асимптотическую границу роста времени выполнения алгоритма.

2. Память:
   - О-малое (Little O): описывает границу роста потребляемой памяти.
   - О-мега (Little Omega): описывает нижнюю границу роста потребляемой памяти.

Примеры временной сложности алгоритмов:
- Сложность O(1) — константная, время выполнения алгоритма не зависит от размера входных данных.
- Сложность O(log n) — логарифмическая, часто встречается в алгоритмах с делением задачи на половины.
- Сложность O(n) — линейная, время выполнения растет линейно от размера входных данных.
- Сложность O(n^2) — квадратичная, время выполнения растет квадратично от размера входных данных.
- Сложность O(n!) — факториальная, очень неэффективный алгоритм, когда время выполнения растет факториально.

Алгоритмы с более низкой асимптотической сложностью обычно считаются более эффективными. 
Однако, важно учитывать, что асимптотическая сложность не учитывает структуру конкретных данных, и что алгоритм с более высокой асимптотической сложностью может быть более эффективен на небольших данных или в конкретной ситуации.

8. Объяснить концепцию рекурсии

Рекурсия в программировании - это процесс, при котором функция вызывает саму себя в теле своего исполнения. 
То есть функция выполняет какие-то действия, а затем при необходимости вызывает саму себя для решения подзадачи определенной структуры. 
Рекурсия используется для решения задач, которые могут быть разделены на подзадачи того же типа.

Основные принципы рекурсии:
1. Базовый случай: в каждой рекурсивной функции должно присутствовать условие, которое определяет когда рекурсия должна завершиться. 
Этот случай называется базовым случаем и обычно представляет собой самый простой вариант задачи, который не требует дальнейшего разделения.

2. Рекурсивный случай: в этой части функция вызывает саму себя для решения более сложной задачи. 
При этом задача разбивается на более простые подзадачи того же типа, которые решаются с использованием рекурсивного вызова.

Эффективное использование рекурсии позволяет реализовать более компактные и элегантные решения для многих задач, таких как обход деревьев, решение задач на графах, вычисление факториала и др. 
Однако необходимо быть внимательным при использовании рекурсии, чтобы избежать бесконечной рекурсии, которая приведет к переполнению стека вызовов и ошибке в выполнении программы.

9. Перечислить основные структуры данных и их свойства (в контексте python)

  1. Строка (String):
       - Это неизменяемый массив байтов, представляющих собой набор символов в Unicode.

  2. Список (List):
     - Упорядоченная коллекция объектов.
     - Может содержать объекты различных типов.
     - Имеет изменяемое содержимое (mutable).
     - Элементы списка доступны по индексу.
  
  3. Кортеж (Tuple):
     - Упорядоченная коллекция объектов.
     - Похож на список, но является неизменяемым (immutable).
     - Может содержать объекты различных типов.
  
  4. Словарь (Dictionary):
     - Неупорядоченная коллекция объектов в формате ключ-значение.
     - Ключи уникальны и неизменяемы.
     - Значения могут быть любого типа.
     - Имеет быстрый доступ к данным по ключу.
  
  5. Множество (Set):
     - Неупорядоченная коллекция уникальных элементов.
     - Поддерживает операции объединения, пересечения, разности и т.д.
     - Может содержать элементы различных типов.
     - Изменяемое содержимое.

10. Реализовать один из предложенных алгоритмов/задач или предложить свой
-
